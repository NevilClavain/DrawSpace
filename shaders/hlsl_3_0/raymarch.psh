/* -*-LIC_BEGIN-*- */
/*
*                                                                          
* DrawSpace Rendering engine                                               
* Emmanuel Chaumont Copyright (c) 2013-2020                     
*                                                                          
* This file is part of DrawSpace.                                          
*                                                                          
*    DrawSpace is free software: you can redistribute it and/or modify     
*    it under the terms of the GNU General Public License as published by  
*    the Free Software Foundation, either version 3 of the License, or     
*    (at your option) any later version.                                   
*                                                                          
*    DrawSpace is distributed in the hope that it will be useful,          
*    but WITHOUT ANY WARRANTY; without even the implied warranty of        
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         
*    GNU General Public License for more details.                          
*                                                                          
*    You should have received a copy of the GNU General Public License     
*    along with DrawSpace.  If not, see <http://www.gnu.org/licenses/>.    
*
*/
/* -*-LIC_END-*- */

float4 Color:				register(c0);

float4x4 matWorld:		    register(c108);
float4x4 matCam:			register(c116);

sampler2D Texture0;

#define RADIUS			4.0f
#define STEPS			100.0f
#define STEP_SIZE		0.1f
#define MIN_DISTANCE	0.001f

struct PS_INTPUT 
{
   float4 wvpPosition : POSITION0;
   float4 wPosition   : TEXCOORD0;
};

float sphereDistance(float3 pos, float3 centre)
{
	return distance(pos, centre) - RADIUS;
}

float4 raymarch(float3 position, float3 direction, float3 centre)
{
	float4 color = { 0.0, 0.0, 0.0, 1.0 };

	float distance;
	bool cont = 1;

	for (int i = 0; i < STEPS && cont == 1; i++)
	{
		// distance from sphere surface
		distance = sphereDistance(position, centre);

		if(distance < MIN_DISTANCE)
		{
			color = i / (float)STEPS;	
			cont = 0;
		}

		position += direction * STEP_SIZE;
	}
	return color;
}

float4 ps_main(PS_INTPUT input) : COLOR0
{	
	float3 worldPosition;
	float3 WorldSpaceCameraPos;
	float3 Center;

	worldPosition.x = input.wPosition.x;
	worldPosition.y = input.wPosition.y;
	worldPosition.z = input.wPosition.z;

	WorldSpaceCameraPos.x = matCam[3][0];
	WorldSpaceCameraPos.y = matCam[3][1];
	WorldSpaceCameraPos.z = matCam[3][2];

	Center.x = matWorld[3][0];
	Center.y = matWorld[3][1];
	Center.z = matWorld[3][2];

	float3 viewDirection = normalize(worldPosition - WorldSpaceCameraPos);

	return raymarch(worldPosition, viewDirection, Center);

   return Color;
}
