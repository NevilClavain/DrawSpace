/* -*-LIC_BEGIN-*- */
/*
*                                                                          
* DrawSpace Rendering engine                                               
* Emmanuel Chaumont Copyright (c) 2013-2020                     
*                                                                          
* This file is part of DrawSpace.                                          
*                                                                          
*    DrawSpace is free software: you can redistribute it and/or modify     
*    it under the terms of the GNU General Public License as published by  
*    the Free Software Foundation, either version 3 of the License, or     
*    (at your option) any later version.                                   
*                                                                          
*    DrawSpace is distributed in the hope that it will be useful,          
*    but WITHOUT ANY WARRANTY; without even the implied warranty of        
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         
*    GNU General Public License for more details.                          
*                                                                          
*    You should have received a copy of the GNU General Public License     
*    along with DrawSpace.  If not, see <http://www.gnu.org/licenses/>.    
*
*/
/* -*-LIC_END-*- */

cbuffer legacyargs : register(b0)
{
    float4   vec[512];
	Matrix   mat[512];
};

#define RADIUS			0.5f
#define STEPS			100.0f
#define STEP_SIZE		0.1f
#define MIN_DISTANCE	0.001f


struct PS_INTPUT 
{
    float4 wvpPosition : SV_POSITION;
	float4 wPosition   : TEXCOORD0;
};

#include "mat_input_constants.hlsl"

float sphereDistance(float3 pos, float3 centre)
{
	return distance(pos, centre) - RADIUS;
}

float compose(float3 pos, float3 centre)
{
	float3 offset = { 0.4, 0.0, 0.0 };
	float distance1 = sphereDistance(pos, centre + offset);
	float distance2 = sphereDistance(pos, centre - offset);

	return min(distance1, distance2);
}

float4 raymarch(float3 position, float3 direction, float3 centre)
{
	float4 color = { 0.0, 0.0, 0.0, 1.0 };

	float distance;
	bool cont = 1;
	
	for (int i = 0; i < STEPS && cont == 1; i++)
	{
		// distance from sphere surface
		distance = compose(position, centre);

		if (distance < MIN_DISTANCE)
		{
			//color = i / (float)STEPS;	

			color.r = 1.0;
			cont = 0;
		}

		position += direction * STEP_SIZE;
	}
	
	return color;
}


float4 ps_main(PS_INTPUT input) : SV_Target
{   
	float3 worldPosition;
	float3 WorldSpaceCameraPos;
	float3 Center;

	float4x4 mat_Cam = mat[matCam_ps];
	float4x4 mat_World = mat[matWorld_ps];

	worldPosition = input.wPosition.xyz;

	WorldSpaceCameraPos.x = mat_Cam[3][0];
	WorldSpaceCameraPos.y = mat_Cam[3][1];
	WorldSpaceCameraPos.z = mat_Cam[3][2];

	Center.x = mat_World[3][0];
	Center.y = mat_World[3][1];
	Center.z = mat_World[3][2];

	float3 viewDirection = normalize(worldPosition - WorldSpaceCameraPos);

	float4 color = raymarch(worldPosition, viewDirection, Center);
	if (color.x == 0.0 && color.y == 0.0 && color.z == 0.0)
	{
		clip(-1.0);
	}

	return color;
}
