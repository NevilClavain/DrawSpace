/* -*-LIC_BEGIN-*- */
/*
*                                                                          
* DrawSpace Rendering engine                                               
* Emmanuel Chaumont Copyright (c) 2013-2020                     
*                                                                          
* This file is part of DrawSpace.                                          
*                                                                          
*    DrawSpace is free software: you can redistribute it and/or modify     
*    it under the terms of the GNU General Public License as published by  
*    the Free Software Foundation, either version 3 of the License, or     
*    (at your option) any later version.                                   
*                                                                          
*    DrawSpace is distributed in the hope that it will be useful,          
*    but WITHOUT ANY WARRANTY; without even the implied warranty of        
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         
*    GNU General Public License for more details.                          
*                                                                          
*    You should have received a copy of the GNU General Public License     
*    along with DrawSpace.  If not, see <http://www.gnu.org/licenses/>.    
*
*/
/* -*-LIC_END-*- */

cbuffer legacyargs : register(b0)
{
    float4 vec[512];
    Matrix mat[512];
};

Texture2D txDiffuse         : register(t0);
SamplerState sam            : register(s0);


struct PS_INTPUT 
{
    float4 Position : SV_POSITION;
	float2 TexCoord0: TEXCOORD0;
};

#include "mat_input_constants.hlsl"
#include "fbm.hlsl"


//Y-axis rotation matrix
float3 rotateY(float3 p, float t)
{
	float cosTheta = cos(t);
	float sinTheta = sin(t);
	float3x3 rot = { cosTheta, 0.0, sinTheta,
				0.0, 1.0, 0.0,
				-sinTheta, 0.0, cosTheta };

	return mul( rot, p );
}

bool raycastSphere(float3 ro, float3 rd, out float3 p0, out float3 p1, float3 center, float r)
{
	// ajoute par moi : si la sphere est derriere la camera et que la camera est en dehors de la sphere 
	float r2 = dot(r, r);
	float d2 = dot(ro - center, ro - center);	
	if (d2 > r2 && dot(center-ro, rd) < 0.0)
	{
		return false;
	}

	////////////////////////////////////
	float A = dot(rd, rd);
	float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));
	float C = dot(ro - center, ro - center) - (r * r);

	float D = B * B - 4.0 * A * C;
	if (D < 0.0)
	{
		return false;
	}
	else
	{
		float t0 = (-B - D) / (2.0 * A);
		float t1 = (-B + D) / (2.0 * A);
		p0 = ro + rd * t0;
		p1 = ro + rd * t1;
		return true;
	}
}

#define MAX_STEPS 128
#define STEP_SIZE 0.05
#define SPHERE_RAY 1.33


float SpiralNoiseC(float3 p)
{
	float nudge = 0.739513;	// size of perpendicular vector
	float normalizer = 1.0 / sqrt(1.0 + nudge * nudge);	// pythagorean theorem on that perpendicular to maintain scale

	float n = 0.0;	// noise amount
	float iter = 1.0;
	for (int i = 0; i < 6; i++)
	{
		// add sin and cos scaled inverse with the frequency
		n += -abs(sin(p.y * iter) + cos(p.x * iter)) / iter;	// abs for a ridged look
		// rotate by adding perpendicular and scaling down
		p.xy += float2(p.y, -p.x) * nudge;
		p.xy *= normalizer;
		// rotate on other axis
		p.xz += float2(p.z, -p.x) * nudge;
		p.xz *= normalizer;
		// increase the frequency
		iter *= 1.733733;
	}
	return n;
}

//Cornette-Shanks phase function
float phase(float mu, float g)
{
	float g2 = g * g;
	return (3.0 * (1.0 - g2) * (1.0 + mu * mu)) / (2.0 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * mu, 1.5));
}

//Density distribution function
float sampleVolume(float3 pos, float seed1, float seed2, bool rotate, float density)
{
	float rr = dot(pos, pos);
	rr = sqrt(rr);
	float f = exp(-rr);
	float p = f * density;

	if (p <= 0.0)
	{
		return p;
	}		
	p += SpiralNoiseC(seed1 + pos * 8.0) * 0.75;

	if(rotate) pos = rotateY(pos, pos.y * SpiralNoiseC(pos * 4.0) * 2.0);

	p += SpiralNoiseC(seed2 + pos * 3.0) * 1.5;
	p *= rr / SPHERE_RAY;

	p = max(0.0, p);

	return p;
}

float4 raymarch(float3 pos, float3 dir, float ds, int s, float seed1, float seed2, bool rotate)
{
	float3	_Light = float3(1.0, 1.0, 1.0);
	float3	_LightPos = float3(0.0, 0.0, 0.0);

	float	_Mie = 0.6;
	float	_G = 0.2;

	float	_LightIntensity = 0.2;
	float3  _Emission = float3(0.3, 0.15, 0.9);
	float3	_Absorption = float3(0.9, 0.7, 0.45);
	float   _Density = 11.0;
	
	float4 result = float4(0.0, 0.0, 0.0, 1.0);

	int nb_steps = min(s, MAX_STEPS);
	for (int i = 0; i < nb_steps; i++)
	{
		float p = sampleVolume(pos, seed1, seed2, rotate, _Density);
		if (p > 0.0)
		{			
			float3 r = _LightPos - pos;
			float atten = _LightIntensity / dot(r, r);
			float3 ext = max(float3(0.000001, 0.000001, 0.000001), (_Absorption * p) + float3(_Mie * p, _Mie * p, _Mie * p));
			float3 trans = exp(-ext * ds);
			float3 lightDir = normalize(r);
			float mu = dot(lightDir, dir);
			float phase_res = phase(mu, _G);

			float3 lum = _Emission + _Light * phase_res * (1.0 - _Absorption) * _Mie * p * atten;
			float3 integral = (lum - (lum * trans)) / ext;

			result.rgb += integral * result.a;
			float3 div = float3(0.3333333, 0.3333333, 0.3333333);

			result.a *= dot(trans, div);

			if (result.a <= 0.1)
			{
				return result;
			}					
		}
		pos += dir * ds;
	}

	result.rgb = clamp(result.rgb, 0, 1);
	
	return result;
}

float3 computePixelColor(float3 current_color, float3 rayOrigin, float4 rayDir, float3 p0, float3 p1, float3 sphere_localpos, 
							float2 resolution, float2 texture_coords, float seed1, float seed2, bool rotate)
{
	Matrix bayer = 
	{ 
		0.0, 0.5, 0.125, 0.625 ,
		0.75, 0.25, 0.875, 0.375,
		0.1875, 0.6875, 0.0625, 0.5625,
		0.9375, 0.4375, 0.8125, 0.3125
	};

	float3 updated_color;

	if (dot(rayOrigin, rayOrigin) < dot(p0, p0))
	{
		//camera a l'interieur de la sphere
		p0 = rayOrigin;
	}

	///////////////////////////////////////////////////////////

	//Bayer matrix ordered depth jittering
	
	float width = (texture_coords.x * resolution.x);
	float height = (texture_coords.y * resolution.y);
	width = fmod(width, 4.0);
	height = fmod(height, 4.0);
	float offset = bayer[int(width)][int(height)];
	p0 -= rayDir * offset * STEP_SIZE * 2.0;
	
	///////////////////////////////////////////////////////////

	p0 -= sphere_localpos;

	float dist = length(p1 - p0);
	int s = int(dist / STEP_SIZE) + 1;

	float4 integral = raymarch(p0, rayDir, STEP_SIZE, s, seed1, seed2, rotate);
	
	updated_color = lerp(integral.rgb, current_color.rgb, integral.a);
	return updated_color;
}

float4 ps_main(PS_INTPUT input) : SV_Target
{
	float4 current_color;

	float4 camera_params = vec[0];
	Matrix mat_cam = mat[1];
	Matrix mat_pos = mat[5];

	float2 resolution = vec[10].xy;

	/////////////////////////////////////////////////////////////////////////////////

	// vec[11] => emission color

	// vec[12] => absorption color

	// vec[13] => .x = number of extra sphere [1-3]
	//         => .y = sphere0 light intensity	

	// vec[14] => 4 spheres density [8.0 - 14.0]

	// vec[15] => 4 spheres rotatey twist [false - true]

	// vec[16] => seed1 for 4 spheres

	// vec[17] => seed2 for 4 spheres

	// vec[20] => sphere1 local pos
	// vec[21] => sphere2 local pos
	// vec[22] => sphere3 local pos



	/////////////////////////////////////////////////////////////////////////////////

	float camera_width = camera_params.x;
	float camera_height = camera_params.y;
	float camera_zn = camera_params.z;

	float3 ray_origin;

	
	Matrix pos_rot = mat_pos;
	pos_rot[3][0] = 0.0;
	pos_rot[3][1] = 0.0;
	pos_rot[3][2] = 0.0;
	pos_rot = transpose(pos_rot); // inverse rot mat


	ray_origin.x = mat_cam[3][0];
	ray_origin.y = mat_cam[3][1];
	ray_origin.z = mat_cam[3][2];


	float3 container_pos;
	container_pos.x = mat_pos[3][0];
	container_pos.y = mat_pos[3][1];
	container_pos.z = mat_pos[3][2];

	float3 globalcontainer_rayOrigin = ray_origin - container_pos;
	float3 localcontainer_rayOrigin = mul(globalcontainer_rayOrigin, pos_rot);



	// compute camera-local ray direction
	float4 localcam_rayDir;
	localcam_rayDir.x = (input.TexCoord0.x - 0.5) * camera_width;
	localcam_rayDir.y = ((1.0 - input.TexCoord0.y) - 0.5) * camera_height;
	localcam_rayDir.z = -camera_zn;
	localcam_rayDir.w = 1.0;

	// compute global ray direction
	mat_cam[3][0] = 0.0;
	mat_cam[3][1] = 0.0;
	mat_cam[3][2] = 0.0;
	float4 global_rayDir = mul(localcam_rayDir, mat_cam);

	// compute local container ray direction
	float4 local_rayDir = mul(global_rayDir, pos_rot);
		
	current_color.rgb = txDiffuse.Sample(sam, input.TexCoord0);

	float3 p0;
	float3 p1;

	float3 sphere0_localpos = { 0.0, 0.0, 0.0 };
	float3 sphere1_localpos = { -0.8, -1.1, 0.0 };
	float3 sphere2_localpos = { 0.0, 0.92, -0.85 };

	if (raycastSphere(localcontainer_rayOrigin, local_rayDir.xyz, p0, p1, sphere0_localpos, SPHERE_RAY)==true)
	{		
		current_color.rgb = computePixelColor(current_color.rgb, localcontainer_rayOrigin, local_rayDir, p0, p1, sphere0_localpos, resolution, input.TexCoord0, 512, 200, true);
	}
	
	
	if (raycastSphere(localcontainer_rayOrigin, local_rayDir.xyz, p0, p1, sphere1_localpos, SPHERE_RAY) == true)
	{
		current_color.rgb = computePixelColor(current_color.rgb, localcontainer_rayOrigin, local_rayDir, p0, p1, sphere1_localpos, resolution, input.TexCoord0, 128, 887, false);
	}
	
	if (raycastSphere(localcontainer_rayOrigin, local_rayDir.xyz, p0, p1, sphere2_localpos, SPHERE_RAY) == true)
	{
		current_color.rgb = computePixelColor(current_color.rgb, localcontainer_rayOrigin, local_rayDir, p0, p1, sphere2_localpos, resolution, input.TexCoord0, 655, 100, true);
	}
	

	current_color.a = 1.0; //alpha value : whatever
	return current_color;
}
